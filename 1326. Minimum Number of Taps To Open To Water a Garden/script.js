/*
SOURCE

    https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/

    
ALGORITHM

    We sort the taps in ascending order based on the leftmost point they can reach.
    We set the current point at 0. Then, in a loop, until we reach the last point,
    we iterate through the taps that reach the current point and among these we select 
    the one that reaches furthest to the right. After each iteration, we are faced 
    with essentially the same problem with the current point moved to the right 
    endpoint of the last selected tap.
    

PROOF OF CORRECTNESS

    We prove that the sequence of taps generated by progressively selecting a tap
    with the furthest reach to the right minimizes tap count by comparing such a 
    sequence with some optimal sequence.
    
    We start with the current point of 0. Since all points need to be watered, we 
    have to select a tap among those that water the current point. If the optimal
    sequence includes the tap with the furthest rightward reach (t_max_right), then 
    our sequence is consistent with it and we can move to the next point. If on the 
    other hand, the optimal sequence does not include t_max_right, then selecting 
    t_max_right will not break the solution because it will still cover all the points
    to the right (and possibly some more) that are covered by whatever tap is selected 
    in its stead in the optimal sequence. So, no additional taps will need to be 
    included in our sequence.

    Thus, at every step, selecting a tap with the furthest reach to the right is
    consistent with an optimal sequence of taps minimizing the tap count.


TIME COMPLEXITY

    T(n) = O(n logn)       

    The algorithm sorts the taps based on comparisons, which takes O(n logn) time.
    Then it makes one pass through the sorted array, taking O(n).

    Thus, T(n) = O(n logn) + O(n) = O(n logn)


SPACE COMPLEXITY

    S(n) = O(n)

    This particular implementation employes an additional array to store the left
    and right endpoints reached by each tap, which takes linear space.

*/

function minTaps(n, ranges) {
    let sortedRanges = ranges.map((val, ind) => ([ind - val, ind + val]))
                             .sort((r1, r2) => r1[0] < r2[0] ? -1 : 1);
    
    let count = 0;
    let nextRange = null;
    let curSpot = 0;                        
    let i = 0;
    
    while (curSpot < n) {
        while (i <= n && sortedRanges[i][0] <= curSpot) {
            if (!nextRange || nextRange[1] < sortedRanges[i][1])
                nextRange = sortedRanges[i];
            ++i;
        }

        if (!nextRange)
            return -1;

        ++count;
        curSpot = nextRange[1];
        nextRange = null;
    }

    return count;
};

let n = 5, ranges = [3,4,1,1,0,0]
let res = minTaps(n, ranges); 
console.log(res);