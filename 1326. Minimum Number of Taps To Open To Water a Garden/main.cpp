/*

SOURCE

    https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/
    

ALGORITHM

    We sort the taps in ascending order based on the leftmost point they can reach.
    We set the current point at 0. Then, in a loop, until we reach the last point,
    we iterate through the taps that reach the current point and among these we select 
    the one that reaches furthest to the right moving the current point to the right
    endpoint of that tap. 


PROOF OF CORRECTNESS

    We prove that the sequence of taps generated by the greedy stratefy of progressively
    selecting a tap with the furthest reach to the right minimizes tap count by comparing 
    such a sequence with some optimal sequence.
    
    We start with the current point of 0. Since all points need to be watered, we 
    have to select a tap among those that water the current point. If the optimal
    sequence includes the tap with the furthest rightward reach (t_max_right), then 
    it is consistent with our strategy - we can include t_max_right in our sequence 
    and move to the next point. If on the other hand, the optimal sequence does not
    include t_max_right, then selecting t_max_right will not break the solution because 
    it will still cover all the points to the right (and possibly some more) that are 
    covered by whatever tap is selected in its stead in the optimal sequence. So, no 
    additional taps will need to be included in our sequence. After each tap selection,
    we are faced with essentially the same problem with the current point moved to the 
    right endpoint of the last selected tap.

    Thus, at every step, selecting the tap with the furthest reach to the right is
    consistent with an optimal sequence of taps minimizing the tap count.


TIME COMPLEXITY

    T(n) = O(n logn)       

    The algorithm sorts the taps based on comparisons, which takes O(n logn) time.
    Then it makes one pass through the sorted array, taking O(n).

    Thus, T(n) = O(n logn) + O(n) = O(n logn)


SPACE COMPLEXITY

    S(n) = O(n)

    This particular implementation employes an additional array to store the left
    and right endpoints reached by each tap, which takes linear space.

*/

#include <vector>
#include <algorithm>
#include <iostream>

class Solution {
public:
    int minTaps(int n, std::vector<int>& ranges) {
        std::vector<std::vector<int>> sortedRanges( ranges.size() );
        for (int i{ 0 }; i < ranges.size(); ++i) {
            sortedRanges[i] = { i - ranges[i], i + ranges[i] };
        }
        std::sort(sortedRanges.begin(), sortedRanges.end(), [](const auto& r1, const auto& r2) {
            return (r1[0] < r2[0]);
        });
        
        int count{ 0 };
        std::vector<int>* nextRange{ nullptr };
        int curSpot{ 0 };                        
        int i{ 0 };
    
        while (curSpot < n) {
            while (i <= n && sortedRanges[i][0] <= curSpot) {
                if (!nextRange || (*nextRange)[1] < sortedRanges[i][1])
                    nextRange = &(sortedRanges[i]);
                ++i;
            }

            if (!nextRange)
                return -1;

            ++count;
            curSpot = (*nextRange)[1];
            nextRange = nullptr;
        }

        return count;
    }
};

int main() {
    int n{ 5 };
    std::vector<int> ranges{ 3,4,1,1,0,0 };
    Solution s{};
    int res{ s.minTaps(n, ranges) };  
    std::cout << res << '\n';
}
